#!/bin/zsh
# Personal configuration - Personal additions not for work machines
# This file is only sourced when dotfiles are installed with personal profile

# ============================================================================
# Git Platform Auto-Detect
# ============================================================================
# Detects the OS and sets GIT_PLATFORM variable so Git can load the
# appropriate ~/.gitconfig.<platform>. If platform is not recognized,
# the variable is not set and commit signing will be disabled.
# ============================================================================

case "$(uname -s)" in
  Darwin)
    export GIT_PLATFORM="macos"   # macOS + 1Password-SSH-agent
    ;;
  Linux)
    # Detect WSL separately
    if grep -qiE "microsoft|wsl" /proc/version 2>/dev/null; then
      export GIT_PLATFORM="wsl"
    else
      export GIT_PLATFORM="linux"
    fi
    ;;
  *)
    unset GIT_PLATFORM            # unknown OS â†’ signing disabled
    ;;
esac

# (Optional) show hint if signing is disabled
[[ -z "${GIT_PLATFORM}" ]] && echo "%F{yellow}[git signing disabled: unknown platform]%f"

# ============================================================================
# Git Auto-Fetch Configuration
# ============================================================================
# Automatically fetch git repositories in the background when entering them
# This keeps the local repository aware of remote changes for accurate prompt display

function git_auto_fetch() {
  # Quick check if we're in a git repo - this stays synchronous
  [[ ! -d .git ]] && return

  # Run all checks and fetch operations asynchronously
  # Use disown to prevent job notifications
  {
    (
      # Use a lockfile to prevent concurrent fetches for the same repo
      local lockfile=".git/AUTO_FETCH_LOCK"
      local fetch_marker=".git/LAST_AUTO_FETCH"

      # Try to acquire lock (atomic operation)
      # If lock exists and is less than 5 minutes old, skip
      if [[ -f "$lockfile" ]]; then
        local lock_age=$(( $(date +%s) - $(stat -f %m "$lockfile" 2>/dev/null || stat -c %Y "$lockfile" 2>/dev/null || echo 0) ))
        if (( lock_age < 300 )); then
          # Lock is fresh, another fetch is likely running
          exit 0
        else
          # Stale lock, remove it
          rm -f "$lockfile"
        fi
      fi

      # Create lock file
      echo $$ > "$lockfile"

      # Ensure lock is removed on exit
      trap "rm -f '$lockfile'" EXIT

      # Check fetch throttle (60 seconds)
      local current_time=$(date +%s)
      local last_fetch=0
      [[ -f $fetch_marker ]] && last_fetch=$(<$fetch_marker)

      if (( current_time - last_fetch <= 60 )); then
        # Too soon since last fetch
        exit 0
      fi

      # Get the remote URL to check if it's a GitHub repository
      local remote_url=$(git config --get remote.origin.url 2>/dev/null)

      # Authentication checks based on repository type
      if [[ "$remote_url" =~ github\.com ]]; then
        # For GitHub repos, check gh auth
        if ! gh auth status &>/dev/null 2>&1; then
          # Not authenticated, create a marker file for user notification
          # This way the main shell doesn't block on the message
          echo "GitHub auto-fetch disabled: run 'gh auth login' to enable" > ".git/AUTO_FETCH_AUTH_MSG"
          exit 0
        fi
      else
        # For non-GitHub repos, check git credentials
        local user_email=$(git config --get user.email 2>/dev/null)
        local user_name=$(git config --get user.name 2>/dev/null)

        if [[ -z "$user_email" ]] || [[ -z "$user_name" ]]; then
          # No credentials configured
          exit 0
        fi
      fi

      # Test connectivity to remote (this is the slowest operation)
      if ! git ls-remote --exit-code -h origin &>/dev/null 2>&1; then
        # Can't reach remote, skip fetch
        exit 0
      fi

      # Perform the actual fetch
      if git fetch --all &>/dev/null 2>&1; then
        # Update timestamp only on successful fetch
        echo $current_time > $fetch_marker
      fi

      # Clean up any auth message if fetch succeeded
      rm -f ".git/AUTO_FETCH_AUTH_MSG"
    ) &>/dev/null 2>&1 &
  } &!

  # Optionally display any pending auth messages (non-blocking)
  if [[ -f .git/AUTO_FETCH_AUTH_MSG ]] && [[ -t 1 ]]; then
    # Only show message if it's recent (less than 1 minute old)
    local msg_age=$(( $(date +%s) - $(stat -f %m ".git/AUTO_FETCH_AUTH_MSG" 2>/dev/null || stat -c %Y ".git/AUTO_FETCH_AUTH_MSG" 2>/dev/null || echo 0) ))
    if (( msg_age < 60 )); then
      cat .git/AUTO_FETCH_AUTH_MSG
      rm -f .git/AUTO_FETCH_AUTH_MSG
    fi
  fi
}

# Hook into directory change
autoload -U add-zsh-hook
add-zsh-hook chpwd git_auto_fetch

# Trigger on shell startup if in a git repo
git_auto_fetch

# ============================================================================
# AI/Claude Development Tools
# ============================================================================
# Claude Code CLI aliases
alias claudem="claude --mcp-config ~/.claude/.mcp.json"  # With MCPs
alias cm="claudem"                         # Short alias for claude with MCPs
alias c="claude"                           # Short alias for basic claude
alias oc="opencode"
alias cs="claude-squad"

# ============================================================================
# API Keys from pass
# ============================================================================
export OPENROUTER_API_KEY="$(pass show api/openrouter 2>/dev/null || echo '')"
export OPENAI_API_KEY="$(pass show api/openai 2>/dev/null || echo '')"

# ============================================================================
# Development Tools
# ============================================================================
# LM Studio CLI (if installed)
[[ -d "$HOME/.lmstudio/bin" ]] && export PATH="$PATH:$HOME/.lmstudio/bin"

# ============================================================================
# 1Password SSH Agent (macOS)
# ============================================================================
if [[ "$OSTYPE" == "darwin"* ]]; then
    export SSH_AUTH_SOCK="$HOME/Library/Group Containers/2BUA8C4S2C.com.1password/t/agent.sock"
fi